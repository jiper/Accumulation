参考地址：https://blog.csdn.net/weixin_39118482


什么是分散加载？
1、分散加载影响的是程序链接规则
2、分散加载告诉链接器应该把代码数据放到具体的物理地址
3、程序镜像（可执行文件）中包含链接器生成的分散加载描述文件，程序运行时，根据分散加载描述文件加载数据和代码

分散加载能做什么？
1、Bootloader&程序升级
2、加速程序运行速度
3、访问扩展存储

如何写分散加载文件：
----------------------------
基本结构：
1、至少3个域：至少一个加载域、建议两个运行域（一个RO运行域、一个RW+ZI运行域）
     我的理解：加载域指的是机器代码或数据的物理存储地址，代码运行时，必须先把代码或数据搬运到到运行域（逻辑上的，实际上加载域和运行域可以一样）。运行域即总线获取代码和数据的地址。
     加载域：用户程序加载地址
     RO运行域：readonly（代码和常量）数据运行域，通常在FLASH中，位置和加载域保持一致
     RW+ZI运行域：通常在SRAM中

-------------------------------
怎么更改程序运行的基址
1、更改跟域的地址范围
2、修改仿真器初始化文件（仿真器初始化文件只有仿真才有效，复位后失效）
FUNC void Setup()
{
    SP = _RDWORD(0x00001000);     //基址偏移到0x00001000
    PC = _RDWORD(0x00001004);
    _WDWORD(0xE000ED08, 0x00001000);  //VTOR寄存器
}

LOAD .\Objects\.axf  INCREMENTAL  //装载axf文件
Setup();

注：
1、仿真器初始化文件只有仿真才有效，复位后失效。所以在实际的使用中，flash起始地址中必须包含栈顶地址和复位向量地址。
2、仿真器初始化文件作用systeminit()之前，如果在systeminit中修改了VTOR寄存器将会导致仿真器初始化文件无效。

-------------------------------------
代码加载到片内SRAM
原则一：第一个RO运行域必须与加载域基地址启动文件和系统初始化文件必须放在和加载域相同的执行域中中，否则系统无法正常运行。
原则二:  启动文件和系统初始化文件必须放在和加载域相同的执行域中中，否则系统无法正常运行。


-------------------------------------
单独函数/变量的指定加载
????<1>使用--split_sections这个编译器选项，为每个函数单独生成一个节（分散加载操作以节为单位），再单独分配这些节；

???
    <2>使用__attribute__((at(address)))来指定放置；

? ? 
   <3>使用__attribute__((section("name")))来放置一个被命名的节；

--------------------------------------
分散加载-堆栈
LOAD_FLASH    起始地址    加载域大小
{
    ...
    ARM_LIB_STACK     起始地址     EMPTY    -栈大小{ } 
    ARM_LIB_HEAP    起始地址    EMPTY     堆大小{ }
    ...

}
一直测试失败，map文件还是以启动文件中为准

--------------------------------------------------
其他：
根区：
1、与加载域起始地址相同的执行域，默认为根区。
2、若其他区域（得在加载域内）需要使用FIXED关键字指定根区；
3、中断向量表，*( InRoot$$Sections )，以及部分ro必须放置在根区	


